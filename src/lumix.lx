@module "build"

@use "std_string" as string
@use "user_input" as ui
@use "module" as module
@use "std_memory" as mem
@use "file_system" as fs
@use "parser" as parser
@use "utility" as util
@use "std_sys" as sys
@use "std_io" as io
@use "getch" as gc

// ============================================================================
// Constants & Type Definitions
// ============================================================================

const BuildConfig -> struct {
    entry_point: *byte,
    output_name: *byte,
    stdlib_path: *byte,
    optimize: int,
    debug_symbols: int,
    verbose: int
};

const NULL_BYTE: Slice = Slice { ptr: "", len: 0 };
const STD_PREFIX_LEN: int = 4;

// ============================================================================
// Global State (Dependency Graph)
// ============================================================================

let g_module_names: [*byte; 100];
let g_file_paths: [*byte; 100];
let g_dependencies: [**byte; 100];
let g_dep_counts: [int; 100];
let g_visited: [int; 100];
let g_in_stack: [int; 100];
let g_graph_size: int = 0;

// ============================================================================
// Entry Point Detection
// ============================================================================

#returns_ownership
const find_entry_point -> fn (scan_path: *byte) *byte {
    let file_count: int = 0;
    let files: **byte = fs::scan_directory(scan_path, &file_count);
    
    if (file_count == 0) return cast<*byte>(0);
    
    let entry_point: *byte = cast<*byte>(0);
    
    loop [i: int = 0](i < file_count) : (i = i + 1) {
        if (util::contains_main_function(files[i]) == 1) {
            // Found it! Copy the filepath
            let len: int = string::strlen(files[i]);
            entry_point = cast<*byte>(alloc((len + 1) * sizeof<byte>));
            mem::memcpy(cast<*void>(entry_point), cast<*void>(files[i]), len);
            entry_point[len] = '\0';
            
            io::print("Auto-detected entry point: %s\n", [io::str_arg(entry_point)]);
            break;
        }
    }
    
    // Free all the file paths
    loop [i: int = 0](i < file_count) : (i = i + 1) {
        free(files[i]);
    }
    free(files);
    
    return entry_point;
}

// ============================================================================
// Dependency Graph Building
// ============================================================================

#takes_ownership
const build_dep_graph -> fn (scan_path: *byte) int {
    g_graph_size = 0;
    
    let cwd: *byte = fs::get_cwd();
    free(cwd);  // Use immediately then free
    
    let file_count: int = 0;
    let files: **byte = fs::scan_directory(scan_path, &file_count);
    
    if (file_count == 0) {
        io::print_err("\nError: No .lx files found in current directory\n", [0]);
        io::print_err("Make sure you're running this from a directory containing .lx files\n", [0]);
        return 0;
    }
    
    // Print file list BEFORE we start transferring ownership
    io::print("Found files:\n", [io::NULL_FORMAT_ARG]);
    loop [i: int = 0](i < file_count) : (i = i + 1) {
        io::print("  - %s\n", [io::str_arg(files[i])]);
    }
    io::print("\n", [io::NULL_FORMAT_ARG]);

    // Process files and transfer ownership to globals
    loop [i: int = 0](i < file_count && g_graph_size < fs::MAX_FILES) : (i = i + 1) {
        let filepath: *byte = files[i];
        
        if (module::extract_module_name(filepath) == cast<*byte>(0)) {
            io::print("Warning: Could not extract module name from %s\n", 
                        [io::str_arg(filepath)]);
            free(filepath);
            continue;
        }
        
        let dep_count: int = 0;
        
        // Transfer ownership to globals
        g_file_paths[g_graph_size] = filepath;
        g_module_names[g_graph_size] = module::extract_module_name(filepath);
        g_dependencies[g_graph_size] = parser::find_imports(filepath, &dep_count);
        g_dep_counts[g_graph_size] = dep_count;
        g_visited[g_graph_size] = 0;
        g_in_stack[g_graph_size] = 0;
        
        g_graph_size = g_graph_size + 1;
    }
    
    // Free any remaining files that werent transferred
    loop [i: int = g_graph_size](i < file_count) : (i = i + 1) {
        free(files[i]);
    }
    
    // Finally free the container
    free(files);
    return g_graph_size;
}

// ============================================================================
// Build Command Construction
// ============================================================================

const has_dep -> fn (slice_ptr: *Slice, slice_count: int, dep_path: *byte) int {
    loop [i: int = 0](i < slice_count) : (i = i + 1) {
        if (string::strcmp(slice_ptr[i].ptr, dep_path) == 0) return 1;
    }
    return 0;
}

#returns_ownership
const convert_std_module_path -> fn (dep_name: *byte) *byte {
    let dep_len: int = string::strlen(dep_name);
    let total_len: int = STD_PREFIX_LEN + (dep_len - STD_PREFIX_LEN) + module::FILE_EXT_LEN + 1;
    
    let dep_path: *byte = cast<*byte>(alloc(total_len * sizeof<byte>));
    
    // Copy "std/"
    dep_path[0] = 's';
    dep_path[1] = 't';
    dep_path[2] = 'd';
    dep_path[3] = '/';
    
    // Copy name after "std_"
    mem::memcpy(cast<*void>(&dep_path[STD_PREFIX_LEN]), 
                cast<*void>(&dep_name[STD_PREFIX_LEN]), 
                dep_len - STD_PREFIX_LEN);
    
    // Append ".lx"
    let base_len: int = STD_PREFIX_LEN + (dep_len - STD_PREFIX_LEN);
    dep_path[base_len + 0] = '.';
    dep_path[base_len + 1] = 'l';
    dep_path[base_len + 2] = 'x';
    dep_path[base_len + 3] = '\0';
    
    return dep_path;  // Caller now owns this memory
}

const add_dependencies_to_cmd -> fn (slice: *Slice, slice_count: *int, config: *BuildConfig) void {
    let allocated_std_paths: [*byte; 50];
    let allocated_count: int = 0;
    
    loop [i: int = 0](i < g_graph_size) : (i = i + 1) {
        loop [j: int = 0](j < g_dep_counts[i]) : (j = j + 1) {
            let dep_name: **byte = g_dependencies[i];
            let dep_path: *byte;
            let needs_free: int = 0;
            
            if (string::strncmp(dep_name[j], "std_", STD_PREFIX_LEN) == 0) {
                dep_path = convert_std_module_path(dep_name[j]);
                needs_free = 1;  // We allocated this, need to free it later
            } else {
                dep_path = dep_name[j];
            }

            if (string::strncmp(dep_path, "std/", STD_PREFIX_LEN) == 0 &&
                has_dep(slice, *slice_count, dep_path) == 0) {
                slice[*slice_count] = slice.null_terminated_slice(dep_path);
                *slice_count = *slice_count + 1;
                slice[*slice_count] = slice.null_terminated_slice(" ");
                *slice_count = *slice_count + 1;
            }
            
            // Track allocated paths for cleanup
            if (needs_free == 1 && allocated_count < 50) {
                allocated_std_paths[allocated_count] = dep_path;
                allocated_count = allocated_count + 1;
            }
        }
        
        if (string::strcmp(g_file_paths[i], config.entry_point) == 0) continue;

        slice[*slice_count] = slice.null_terminated_slice(g_file_paths[i]);
        *slice_count = *slice_count + 1;
        slice[*slice_count] = slice.null_terminated_slice(" ");
        *slice_count = *slice_count + 1;
    }
}

const build_compile_command -> fn (config: *BuildConfig) String {
    let slice: *Slice = cast<*Slice>(alloc(200 * sizeof<Slice>));
    defer { free(slice); }
    
    let slice_count: int = 0;
    
    // Base command
    slice[slice_count++] = slice.null_terminated_slice("luma ");
    slice[slice_count++] = slice.null_terminated_slice(config.entry_point);
    slice[slice_count++] = slice.null_terminated_slice(" ");
    
    // Add libraries flag if needed
    slice[slice_count++] = slice.null_terminated_slice("-l ");
    
    // Add dependencies and files
    add_dependencies_to_cmd(slice, &slice_count, config);
    
    // Add output name
    slice[slice_count++] = slice.null_terminated_slice("-name ");
    slice[slice_count++] = slice.null_terminated_slice(config.output_name);
    slice[slice_count] = NULL_BYTE;
    
    let cmd_str: String;
    cmd_str = cmd_str.concat_strs(slice, slice_count);
    return cmd_str;
}

// ============================================================================
// Build Commands
// ============================================================================

const build -> fn (config: *BuildConfig) int {
    io::print("\n=== Building Luma Project ===\n", [io::NULL_FORMAT_ARG]);
    io::print("Entry point: %s\n", [io::str_arg(config.entry_point)]);
    io::print("Output name: %s\n", [io::str_arg(config.output_name)]);
    
    if (util::file_exists(config.entry_point) == 0) {
        io::print_err("\nError: Entry point file '%s' does not exist\n", 
                     [cast<int>(config.entry_point)]);
        return 1;
    }
    
    if (config.verbose == 1) {
        io::print("\nAnalyzing dependencies...\n", [io::NULL_FORMAT_ARG]);
    }
    
    if (build_dep_graph(".") == 0) return 1;

    io::print("Compiling modules...\n", [io::NULL_FORMAT_ARG]);

    let cmd_str: String = build_compile_command(config);
    defer { string::free_string(&cmd_str); }

    io::print("Executing command:\n%s\n\t", [io::str_arg(cmd_str.slice.ptr)]);

    let compile_result: int = system(cmd_str.slice.ptr);
    if (compile_result != 0) {
        io::print_err("\nError: Build failed with exit code %d\n\n", [compile_result]);
        return compile_result;
    }

    io::print("\nBuild completed successfully. Output: %s\n\n", 
             [io::str_arg(config.output_name)]);

    loop [i: int = 0](i < g_graph_size) : (i = i + 1) {
        loop [j: int = 0](j < g_dep_counts[i]) : (j = j + 1) {
            let deps: **byte = g_dependencies[i];
            free(deps[j]);
        }
        free(g_dependencies[i]);
        free(g_module_names[i]);
        free(g_file_paths[i]);
    }

    return 0;
}

const clean -> fn () int {
    io::print("\n=== Cleaning Build Artifacts ===\n", [io::NULL_FORMAT_ARG]);
    
    
    let confirm: int = gc::get_yes_no("Are you sure you want to clean build artifacts?");
    if (confirm == 0) {
        io::print("Clean operation cancelled.\n\n", [io::NULL_FORMAT_ARG]);
        return 0;
    }

    io::print("Cleaning...\n", [io::NULL_FORMAT_ARG]);
    system("sudo rm -rf obj main /tmp/luma_*.txt");

    io::print("Cleaned build artifacts successfully.\n\n", [io::NULL_FORMAT_ARG]);
    return 0;
}

const show_deps -> fn () int {
    io::print("\n=== Dependency Tree ===\n", [io::NULL_FORMAT_ARG]);
    
    if (build_dep_graph(".") == 0) return 1;
    
    io::print("\nModule dependencies:\n", [io::NULL_FORMAT_ARG]);
    
    loop [i: int = 0](i < g_graph_size) : (i = i + 1) {
        io::print("\n  %s", [io::str_arg(g_module_names[i])]);

        if (g_dep_counts[i] == 0) {
            io::print(" (no dependencies)", [io::NULL_FORMAT_ARG]);
            continue; 
        }

        io::print(" depends on:", [io::NULL_FORMAT_ARG]);
        loop [j: int = 0](j < g_dep_counts[i]) : (j = j + 1) {
            let deps: **byte = g_dependencies[i];
            io::print("\n    - %s", [io::str_arg(deps[j])]);
        }
    }
    
    io::print("\n", [io::NULL_FORMAT_ARG]);
    return 0;
}

// ============================================================================
// Main Entry Point
// ============================================================================

pub const main -> fn () int {
    io::print("\n========================================\n", [io::NULL_FORMAT_ARG]);
    io::print("         Luma Build System v1.6         \n", [io::NULL_FORMAT_ARG]);
    io::print("========================================\n", [io::NULL_FORMAT_ARG]);
    
    let cmd_buffer: [byte; 64];
    ui::get_user_input("\nCommand (build/clean/deps): ", "", 
                   cast<*byte>(&cmd_buffer), 64);
    let cmd: *byte = cast<*byte>(&cmd_buffer);
    
    if (string::strcmp(cmd, "build") == 0) {
        let output_buffer: [byte; 256];
        
        // Try to auto-detect entry point
        io::print("\nScanning for entry point...\n", [io::NULL_FORMAT_ARG]);
        let auto_entry: *byte = find_entry_point(".");
        let entry_point: *byte;
        
        if (auto_entry != cast<*byte>(0)) {
            // Found automatically
            entry_point = auto_entry;
        } else {
            // Manual input required
            io::print("No entry point auto-detected.\n", [io::NULL_FORMAT_ARG]);
            let entry_buffer: [byte; 256];
            entry_point = ui::get_user_input(
                "Entry point file (press Enter for 'main.lx'): ",
                "main.lx",
                cast<*byte>(&entry_buffer),
                256
            );
        }

        let output_name: *byte = ui::get_user_input(
            "Output binary name (press Enter for 'main'): ",
            "main",
            cast<*byte>(&output_buffer),
            256
        );
        
        let config: BuildConfig = BuildConfig {
            entry_point: entry_point,
            output_name: output_name,
            stdlib_path: "std",
            optimize: 0,
            debug_symbols: 1,
            verbose: 1
        };
        
        let result: int = build(&config);
        
        // Clean up auto-detected entry point if allocated
        if (auto_entry != cast<*byte>(0)) {
            free(auto_entry);
        }
        
        return result;
        
    } elif (string::strcmp(cmd, "clean") == 0) {
        return clean();
        
    } elif (string::strcmp(cmd, "deps") == 0) {
        return show_deps();
        
    } else {
        io::print("\nUnknown command: %s\n", [io::str_arg(cmd)]);
        io::print("\nUsage:\n", [io::NULL_FORMAT_ARG]);
        io::print("  build - Build the project\n", [io::NULL_FORMAT_ARG]);
        io::print("  clean - Clean build artifacts\n", [io::NULL_FORMAT_ARG]);
        io::print("  deps  - Show dependency tree\n\n", [io::NULL_FORMAT_ARG]);
        return 1;
    }
    
    return 0;
}
