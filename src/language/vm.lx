@module "vm"

@use "debug" as debug
@use "std_sys" as sys
@use "symbols" as sym
@use "std_io" as io

const STACK_SIZE: int = 256;
const PROGRAM_SIZE: int = 1024;

#returns_ownership
pub const create_vm -> fn () VM {
  return VM { 
    sp: -1,
    pc:  0,
    stack: cast<*int>(alloc(sizeof<int> * STACK_SIZE)),
    program: cast<*byte>(alloc(sizeof<byte> * PROGRAM_SIZE))
  };
}

#takes_ownership
pub const free_vm -> fn (vm: *VM) void {
  free(vm.stack);
  free(vm.program);

  vm.sp = -1;
  vm.pc = 0;
}

const check_stack_has_values -> fn (v: *VM, count: int) void {
  if (v.sp < count - 1) {
    io::print_err("Stack Underflow! Need %d value(s),
                  but stack has %d\n", [count, v.sp + 1]);
    sys::exit(1);
  }
}

pub const push -> fn (v: *VM, value: int) void {
  if (v.sp >= STACK_SIZE - 1) {
    io::print_err("Stack Overflow!\n", [0]);
    sys::exit(1);
  }

  v.sp = v.sp + 1;
  v.stack[v.sp] = value;
  
  debug::trace_push(value);
}

pub const pop -> fn (v: *VM) int {
  check_stack_has_values(v, 1);

  let result: int = v.stack[v.sp];
  v.sp = v.sp - 1;
  
  debug::trace_pop(result);
  
  return result; 
}

pub const write_int -> fn (prog: *byte, pc: *int, val: int) void {
  loop [i: int = 0](i < 8) : (++i) {
    prog[*pc] = cast<byte>((val >> (i * 8)) & 255);
    *pc = *pc + 1;
  }
}

const power -> fn (base: int, exponent: int) int {
  if (exponent == 0) return 1;

  let result: int = 1;
  let e: int = exponent;

  if (e < 0) {
    base = 1;
    e = -e;
  }

  loop (e > 0) : (--e) { result = result * base; }
  return result;
}

const read_int -> fn (v: *VM) int {
  return ((cast<int>(v.program[v.pc + 0]) & 255) << 0)  |
         ((cast<int>(v.program[v.pc + 1]) & 255) << 8)  |
         ((cast<int>(v.program[v.pc + 2]) & 255) << 16) |
         ((cast<int>(v.program[v.pc + 3]) & 255) << 24) |
         ((cast<int>(v.program[v.pc + 4]) & 255) << 32) |
         ((cast<int>(v.program[v.pc + 5]) & 255) << 40) |
         ((cast<int>(v.program[v.pc + 6]) & 255) << 48) |
         ((cast<int>(v.program[v.pc + 7]) & 255) << 56); 
}

const preform_binary -> fn (v: *VM, op: byte) void {
  check_stack_has_values(v, 2);
  
  let b: int = pop(v);
  let a: int = pop(v);
  let result: int = 0;

  switch (op) {
    '+' -> result = a + b;
    '-' -> result = a - b;
    '*' -> result = a * b;
    '/' -> result = a / b;
    '%' -> result = a % b;
    '^' -> result = power(a, b); 
    '<' -> if (a < b)  result = 1; else result = 0;
    '=' -> if (a == b) result = 1; else result = 0;
  }
  
  push(v, result);
}

const preform_unary -> fn (v: *VM, op: byte) void {
  check_stack_has_values(v, 1);
  
  let a: int = pop(v);
  let result: int = 0;

  switch (op) {
    '-' -> result = -a;
  }
  
  push(v, result);
}

pub const vm_execute -> fn (v: *VM) void {
  debug::trace_header();
  
  loop {
    let op: byte = v.program[v.pc];
    
    debug::trace_instruction(v.pc, cast<int>(op));
    
    v.pc = v.pc + 1;

    switch(cast<int>(op)) {
      sym::Opcode::OP_PUSH -> {
        let val: int = read_int(v); 
        v.pc = v.pc + 8;
        push(v, val);
      }
      sym::Opcode::OP_POP  -> { pop(v); }
      sym::Opcode::OP_DUP -> {
        check_stack_has_values(v, 1);
        let value: int = v.stack[v.sp];
        push(v, value);
      }
      sym::Opcode::OP_HALT -> {
        debug::trace_halt();
        return;
      }

      sym::Opcode::OP_PRINT -> {
        check_stack_has_values(v, 1);
        io::print("%d\n", [io::int_arg(v.stack[v.sp])]);
      }

      // Binary Instructions
      sym::Opcode::OP_ADD -> preform_binary(v, '+');
      sym::Opcode::OP_SUB -> preform_binary(v, '-');
      sym::Opcode::OP_MUL -> preform_binary(v, '*');
      sym::Opcode::OP_DIV -> preform_binary(v, '/');
      sym::Opcode::OP_MOD -> preform_binary(v, '%');
      sym::Opcode::OP_LT  -> preform_binary(v, '<');
      sym::Opcode::OP_EQ  -> preform_binary(v, '=');
      sym::Opcode::OP_EXP -> preform_binary(v, '^');

      // Unary Instructions
      sym::Opcode::OP_NEG -> preform_unary(v, '-');

      // Jump Instructions
      sym::Opcode::OP_JMP -> v.pc = read_int(v);
      sym::Opcode::OP_JZ  -> {
        let target: int = read_int(v);
        v.pc = v.pc + 8;  // Move past the jump target
  
        check_stack_has_values(v, 1);
        let condition: int = pop(v);
  
        if (condition == 0) {
          v.pc = target;
        }
      }
      sym::Opcode::OP_JNZ  -> {
        let target: int = read_int(v);
        v.pc = v.pc + 8;  // Move past the jump target
  
        check_stack_has_values(v, 1);
        let condition: int = pop(v);
  
        if (condition != 0) {
           v.pc = target;
        }
      }

      _ -> {
        io::print_err("Unknown Opcode!!\n", [0]);
        return;
      }
    }
    
    debug::print_stack(v);
    debug::trace_separator();
  }
}

